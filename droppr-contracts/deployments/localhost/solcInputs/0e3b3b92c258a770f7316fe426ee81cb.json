{
  "language": "Solidity",
  "sources": {
    "contracts/upgradeability/EternalStorageProxy.sol": {
      "content": "pragma solidity ^0.4.18;\n\nimport \"./EternalStorage.sol\";\nimport \"./OwnedUpgradeabilityProxy.sol\";\n\n\n/**\n * @title EternalStorageProxy\n * @dev This proxy holds the storage of the token contract and delegates every call to the current implementation set.\n * Besides, it allows to upgrade the token's behaviour towards further implementations, and provides basic\n * authorization control functionalities\n */\ncontract EternalStorageProxy is EternalStorage, OwnedUpgradeabilityProxy {}\n"
    },
    "contracts/upgradeability/EternalStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.18 <= 0.8.0;\n\n/**\n * @title EternalStorage\n * @dev This contract holds all the necessary state variables to carry out the storage of any contract.\n */\ncontract EternalStorage {\n\n  mapping(bytes32 => uint256) internal uintStorage;\n  mapping(bytes32 => string) internal stringStorage;\n  mapping(bytes32 => address) internal addressStorage;\n  mapping(bytes32 => bytes) internal bytesStorage;\n  mapping(bytes32 => bool) internal boolStorage;\n  mapping(bytes32 => int256) internal intStorage;\n\n\n\n}\n"
    },
    "contracts/upgradeability/OwnedUpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.4.18;\n\nimport './UpgradeabilityProxy.sol';\nimport './UpgradeabilityOwnerStorage.sol';\n\n/**\n * @title OwnedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n */\ncontract OwnedUpgradeabilityProxy is UpgradeabilityOwnerStorage, UpgradeabilityProxy {\n  /**\n  * @dev Event to show ownership has been transferred\n  * @param previousOwner representing the address of the previous owner\n  * @param newOwner representing the address of the new owner\n  */\n  event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n\n  /**\n  * @dev the constructor sets the original owner of the contract to the sender account.\n  */\n  function OwnedUpgradeabilityProxy() public {\n    setUpgradeabilityOwner(msg.sender);\n  }\n\n  /**\n  * @dev Throws if called by any account other than the owner.\n  */\n  modifier onlyProxyOwner() {\n    require(msg.sender == proxyOwner());\n    _;\n  }\n\n  /**\n   * @dev Tells the address of the proxy owner\n   * @return the address of the proxy owner\n   */\n  function proxyOwner() public view returns (address) {\n    return upgradeabilityOwner();\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n    require(newOwner != address(0));\n    ProxyOwnershipTransferred(proxyOwner(), newOwner);\n    setUpgradeabilityOwner(newOwner);\n  }\n\n  /**\n   * @dev Allows the upgradeability owner to upgrade the current version of the proxy.\n   * @param version representing the version name of the new implementation to be set.\n   * @param implementation representing the address of the new implementation to be set.\n   */\n  function upgradeTo(string version, address implementation) public onlyProxyOwner {\n    _upgradeTo(version, implementation);\n  }\n\n  /**\n   * @dev Allows the upgradeability owner to upgrade the current version of the proxy and call the new implementation\n   * to initialize whatever is needed through a low level call.\n   * @param version representing the version name of the new implementation to be set.\n   * @param implementation representing the address of the new implementation to be set.\n   * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\n   * signature of the implementation to be called with the needed payload\n   */\n  function upgradeToAndCall(string version, address implementation, bytes data) payable public onlyProxyOwner {\n    upgradeTo(version, implementation);\n    require(this.call.value(msg.value)(data));\n  }\n}\n"
    },
    "contracts/upgradeability/UpgradeabilityProxy.sol": {
      "content": "pragma solidity ^0.4.18;\n\nimport './Proxy.sol';\nimport './UpgradeabilityStorage.sol';\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded\n */\ncontract UpgradeabilityProxy is Proxy, UpgradeabilityStorage {\n  /**\n  * @dev This event will be emitted every time the implementation gets upgraded\n  * @param version representing the version name of the upgraded implementation\n  * @param implementation representing the address of the upgraded implementation\n  */\n  event Upgraded(string version, address indexed implementation);\n\n  /**\n  * @dev Upgrades the implementation address\n  * @param version representing the version name of the new implementation to be set\n  * @param implementation representing the address of the new implementation to be set\n  */\n  function _upgradeTo(string version, address implementation) internal {\n    require(_implementation != implementation);\n    _version = version;\n    _implementation = implementation;\n    Upgraded(version, implementation);\n  }\n}\n"
    },
    "contracts/upgradeability/UpgradeabilityOwnerStorage.sol": {
      "content": "pragma solidity ^0.4.18;\n\n\n/**\n * @title UpgradeabilityOwnerStorage\n * @dev This contract keeps track of the upgradeability owner\n */\ncontract UpgradeabilityOwnerStorage {\n  // Owner of the contract\n  address private _upgradeabilityOwner;\n\n  /**\n   * @dev Tells the address of the owner\n   * @return the address of the owner\n   */\n  function upgradeabilityOwner() public view returns (address) {\n    return _upgradeabilityOwner;\n  }\n\n  /**\n   * @dev Sets the address of the owner\n   */\n  function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {\n    _upgradeabilityOwner = newUpgradeabilityOwner;\n  }\n}\n"
    },
    "contracts/upgradeability/Proxy.sol": {
      "content": "pragma solidity ^0.4.18;\n\n/**\n * @title Proxy\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n */\ncontract Proxy {\n\n  /**\n  * @dev Tells the address of the implementation where every call will be delegated.\n  * @return address of the implementation to which it will be delegated\n  */\n  function implementation() public view returns (address);\n\n  /**\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n  * This function will return whatever the implementation call returns\n  */\n  function () payable public {\n    address _impl = implementation();\n    require(_impl != address(0));\n\n    assembly {\n      let ptr := mload(0x40)\n      calldatacopy(ptr, 0, calldatasize)\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n      let size := returndatasize\n      returndatacopy(ptr, 0, size)\n\n      switch result\n      case 0 { revert(ptr, size) }\n      default { return(ptr, size) }\n    }\n  }\n}\n"
    },
    "contracts/upgradeability/UpgradeabilityStorage.sol": {
      "content": "pragma solidity ^0.4.18;\n\n/**\n * @title UpgradeabilityStorage\n * @dev This contract holds all the necessary state variables to support the upgrade functionality\n */\ncontract UpgradeabilityStorage {\n  // Version name of the current implementation\n  string internal _version;\n\n  // Address of the current implementation\n  address internal _implementation;\n\n  /**\n  * @dev Tells the version name of the current implementation\n  * @return string representing the name of the current version\n  */\n  function version() public view returns (string) {\n    return _version;\n  }\n\n  /**\n  * @dev Tells the address of the current implementation\n  * @return address of the current implementation\n  */\n  function implementation() public view returns (address) {\n    return _implementation;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}